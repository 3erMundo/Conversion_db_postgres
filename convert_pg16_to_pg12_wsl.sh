#!/bin/bash

# Script para convertir backup de PostgreSQL 16 a PostgreSQL 12
# Optimizado para WSL en Windows
# Uso: ./convert_pg16_to_pg12.sh <archivo_entrada> <archivo_salida>

set -e  # Salir si hay algún error

# Colores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # Sin color

# Función para mostrar mensajes
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[✓]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[⚠]${NC} $1"
}

log_error() {
    echo -e "${RED}[✗]${NC} $1"
}

# Banner
echo -e "${BLUE}"
echo "=========================================="
echo "  Conversión PostgreSQL 16 → 12"
echo "=========================================="
echo -e "${NC}"

# Validar argumentos
if [ "$#" -ne 2 ]; then
    log_error "Uso incorrecto"
    echo ""
    echo "Uso: $0 <archivo_entrada> <archivo_salida>"
    echo ""
    echo "Ejemplo:"
    echo "  $0 /mnt/c/Backups/municipios.sql /mnt/c/Backups/municipios_pg12.sql"
    echo ""
    exit 1
fi

INPUT_FILE="$1"
OUTPUT_FILE="$2"

log_info "Archivo de entrada: $INPUT_FILE"
log_info "Archivo de salida: $OUTPUT_FILE"
echo ""

# Validar que el archivo de entrada existe
if [ ! -f "$INPUT_FILE" ]; then
    log_error "El archivo de entrada no existe: $INPUT_FILE"
    exit 1
fi

# Validar que el archivo es legible
if [ ! -r "$INPUT_FILE" ]; then
    log_error "No se puede leer el archivo: $INPUT_FILE"
    log_warning "Verifica los permisos del archivo"
    exit 1
fi

# Mostrar tamaño del archivo
FILE_SIZE=$(du -h "$INPUT_FILE" | cut -f1)
log_info "Tamaño del archivo: $FILE_SIZE"
echo ""

# Validar que parece ser un backup de PostgreSQL
log_info "Validando formato del backup..."
if head -50 "$INPUT_FILE" | grep -q "PostgreSQL"; then
    log_success "El archivo parece ser un backup válido de PostgreSQL"
    
    # Detectar versión
    PG_VERSION=$(head -50 "$INPUT_FILE" | grep -oP "PostgreSQL \K[0-9.]+" | head -1)
    if [ -n "$PG_VERSION" ]; then
        log_info "Versión detectada: PostgreSQL $PG_VERSION"
    fi
else
    log_warning "No se pudo detectar que sea un backup de PostgreSQL"
    log_warning "Continuando de todas formas..."
fi
echo ""

# Estimar tiempo basado en tamaño
FILE_SIZE_MB=$(stat -c%s "$INPUT_FILE" | awk '{print int($1/1024/1024)}')
ESTIMATED_TIME=$((FILE_SIZE_MB / 100))  # ~100MB por minuto
if [ $ESTIMATED_TIME -lt 1 ]; then
    ESTIMATED_TIME=1
fi

log_info "Tiempo estimado de procesamiento: ~${ESTIMATED_TIME} minuto(s)"
echo ""

# Confirmar antes de proceder
read -p "¿Deseas continuar? (s/n): " -n 1 -r
echo ""
if [[ ! $REPLY =~ ^[SsYy]$ ]]; then
    log_warning "Operación cancelada por el usuario"
    exit 0
fi
echo ""

log_info "Iniciando conversión..."
echo ""

# Crear archivo temporal
TEMP_FILE="${OUTPUT_FILE}.tmp"

# Función de limpieza en caso de error
cleanup() {
    if [ -f "$TEMP_FILE" ]; then
        log_warning "Limpiando archivos temporales..."
        rm -f "$TEMP_FILE"
    fi
}
trap cleanup EXIT

# Detectar si el archivo está comprimido
if [[ "$INPUT_FILE" == *.gz ]]; then
    log_info "Detectado archivo comprimido (.gz)"
    DECOMPRESS="gunzip -c"
elif [[ "$INPUT_FILE" == *.bz2 ]]; then
    log_info "Detectado archivo comprimido (.bz2)"
    DECOMPRESS="bunzip2 -c"
else
    DECOMPRESS="cat"
fi

# Procesar el archivo con barra de progreso si pv está disponible
if command -v pv &> /dev/null; then
    log_info "Procesando con indicador de progreso..."
    $DECOMPRESS "$INPUT_FILE" | pv -s $(stat -c%s "$INPUT_FILE") | \
        sed 's/PostgreSQL 16/PostgreSQL 12/g' | \
        sed 's/16\.[0-9]/12.0/g' | \
        sed '/LOCALE_PROVIDER = icu/d' | \
        sed '/ICU_LOCALE/d' | \
        sed '/ICU_RULES/d' | \
        sed '/BUILTIN = true/d' | \
        sed 's/LOCALE_PROVIDER = libc//' | \
        sed 's/COLLATION "icu_[^"]*"/COLLATION "default"/g' | \
        sed 's/GENERATED ALWAYS AS IDENTITY/SERIAL/g' | \
        sed 's/GENERATED BY DEFAULT AS IDENTITY/SERIAL/g' | \
        sed 's/^\([[:space:]]*\)MERGE INTO/\1-- MERGE INTO (NO SOPORTADO EN PG12)/' | \
        sed '/^ALTER TABLE.*SET \(LOGGED\|UNLOGGED\);/d' | \
        sed 's/jsonb_path_query_first/jsonb_path_query/g' | \
        sed 's/json_serialize/json/g' | \
        sed 's/INCLUDE ([^)]*)//g' | \
        sed 's/^\(.*ALTER DATABASE.*SET.*locale.*\)/-- \1/' | \
        sed 's/^\(.*ALTER DATABASE.*LOCALE.*\)/-- \1/' | \
        sed '/SET default_table_access_method/d' | \
        sed '/SET default_toast_compression/d' \
        > "$TEMP_FILE"
else
    log_info "Procesando (sin indicador de progreso)..."
    $DECOMPRESS "$INPUT_FILE" | \
        sed 's/PostgreSQL 16/PostgreSQL 12/g' | \
        sed 's/16\.[0-9]/12.0/g' | \
        sed '/LOCALE_PROVIDER = icu/d' | \
        sed '/ICU_LOCALE/d' | \
        sed '/ICU_RULES/d' | \
        sed '/BUILTIN = true/d' | \
        sed 's/LOCALE_PROVIDER = libc//' | \
        sed 's/COLLATION "icu_[^"]*"/COLLATION "default"/g' | \
        sed 's/GENERATED ALWAYS AS IDENTITY/SERIAL/g' | \
        sed 's/GENERATED BY DEFAULT AS IDENTITY/SERIAL/g' | \
        sed 's/^\([[:space:]]*\)MERGE INTO/\1-- MERGE INTO (NO SOPORTADO EN PG12)/' | \
        sed '/^ALTER TABLE.*SET \(LOGGED\|UNLOGGED\);/d' | \
        sed 's/jsonb_path_query_first/jsonb_path_query/g' | \
        sed 's/json_serialize/json/g' | \
        sed 's/INCLUDE ([^)]*)//g' | \
        sed 's/^\(.*ALTER DATABASE.*SET.*locale.*\)/-- \1/' | \
        sed 's/^\(.*ALTER DATABASE.*LOCALE.*\)/-- \1/' | \
        sed '/SET default_table_access_method/d' | \
        sed '/SET default_toast_compression/d' \
        > "$TEMP_FILE"
fi

echo ""

# Verificar que se creó el archivo temporal
if [ ! -f "$TEMP_FILE" ]; then
    log_error "Error al crear el archivo de salida"
    exit 1
fi

# Verificar que el archivo no está vacío
if [ ! -s "$TEMP_FILE" ]; then
    log_error "El archivo de salida está vacío"
    rm -f "$TEMP_FILE"
    exit 1
fi

# Mover el archivo temporal al archivo final
mv "$TEMP_FILE" "$OUTPUT_FILE"

OUTPUT_SIZE=$(du -h "$OUTPUT_FILE" | cut -f1)

echo ""
log_success "¡Conversión completada exitosamente!"
echo ""
echo "=========================================="
log_info "Archivo generado: $OUTPUT_FILE"
log_info "Tamaño: $OUTPUT_SIZE"
echo "=========================================="
echo ""

# Validaciones post-conversión
log_info "Ejecutando validaciones..."
echo ""

# Buscar posibles problemas
MERGE_COUNT=$(grep -c "MERGE INTO" "$OUTPUT_FILE" 2>/dev/null || echo "0")
if [ "$MERGE_COUNT" -gt 0 ]; then
    log_warning "Se encontraron $MERGE_COUNT comandos MERGE (comentados - requieren conversión manual)"
fi

PG16_REF=$(grep -c "PostgreSQL 16" "$OUTPUT_FILE" 2>/dev/null || echo "0")
if [ "$PG16_REF" -gt 0 ]; then
    log_warning "Aún hay $PG16_REF referencias a PostgreSQL 16 en el archivo"
fi

# Contar tablas
TABLE_COUNT=$(grep -c "CREATE TABLE" "$OUTPUT_FILE" 2>/dev/null || echo "0")
log_info "Tablas detectadas: $TABLE_COUNT"

echo ""
echo "=========================================="
echo -e "${GREEN}SIGUIENTE PASO: RESTAURAR EN POSTGRESQL 12${NC}"
echo "=========================================="
echo ""
echo "1. Crear base de datos en PostgreSQL 12:"
echo -e "   ${YELLOW}createdb -U postgres municipios${NC}"
echo ""
echo "2. Restaurar el backup convertido:"
echo -e "   ${YELLOW}psql -U postgres -d municipios -f \"$OUTPUT_FILE\" 2>&1 | tee restore.log${NC}"
echo ""
echo "3. Revisar el log de restauración:"
echo -e "   ${YELLOW}grep -i error restore.log${NC}"
echo ""
echo "=========================================="
echo -e "${RED}⚠️  IMPORTANTE${NC}"
echo "=========================================="
echo "• SIEMPRE prueba primero en un ambiente de desarrollo"
echo "• Revisa el archivo restore.log después de restaurar"
echo "• Valida que los datos se importaron correctamente"
echo "• NO uses esto directamente en producción sin probar"
echo ""
